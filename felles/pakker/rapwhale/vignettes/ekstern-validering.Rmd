---
title: "Ekstern validering"
author: "Per Erik Haugedal og Karl Ove Hufthammer"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Ekstern validering}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r pakkelasting, include = FALSE}
suppressPackageStartupMessages({
  library(rapwhale)
  library(dplyr)
  library(kableExtra)
})
```

```{r kable-format, include = FALSE}
lag_kable = function(d, ...) {
  d %>%
    kbl() %>%
    kable_classic("hover", ...)
}
```

## Innleiing

I `rapwhale` finst ein infrastruktur – eit sett R-funksjonar og tilhøyrande
metodikk – for *ekstern validering* av registerdata. Målet med denne
har vore å gjera det enklare, raskare og sikrare å gjennomføra ekstern
validering av høg kvalitet.

*Ekstern validering* går her ut på å finna ut om dataa i registeret er 
lik dataa i ein gitt gullstandard, typisk ein pasientjournal.
For meir informasjon, sjå
[SKDE sin artikkel om korrektheit](https://www.kvalitetsregistre.no/korrekthet).

Me har laga eit standardisert format for valideringsdata og
eit sett R-funksjonar for å analysera og laga datasett på dette formatet.
La oss først sjå nærare på formatet me har komme fram til.


## Format til valideringsdatasett

I eit valideringsdatsett må me for kvar måling
(for eksempel vekta eller høgda til ein person)
registrera verdien av målinga i registeret (*intern verdi*) og
tilhøyrande verdi i den eksterne kjelda (*ekstern verdi*), gullstandarden.
I tillegg treng me informasjon om kva pasient eller forløp
verdien gjeld samt kva for variabel det er snakk om.

### Første forsøk på eit format

I utgangspunktet verkar eit format som dette fornuftig:

```{r superenkelt eksempel, echo = FALSE}
d_banalt = tibble::tribble(
  ~pasid, ~varnamn, ~verdi_intern, ~verdi_ekstern,
  5, "vekt", 78, 78,
  7, "hogd", 196, 194
)
lag_kable(d_banalt, full_width = FALSE, position = "left")
```

Her kan me registrera høgda og vekta til kvar pasient
(identifisert med pasient-ID, `pasid`),
både internt i registeret og i den eksterne kjelda.

Men for meir realistiske datasett støyter me fort på problem,
som me har løyst med eit utvida og endeleg format.


### Utvida og endeleg format

Det er tre potensielle problem –
at ein pasient kan ha fleire målingar av same variabel,
at me kan ha målingar av ulike typar variabel (eksempelvis både tal og datoar)
og at indeksvariablar kan ha same namn som verdivariablane.

Ein pasient kan ha fleire registreringar på same variabel
dersom han vore til fleire undersøkingar.
Det løyser me enkelt ved å tillata fleire *indeksvariablar*,
for eksempel både pasient-ID og undersøkingsdato.
Dette er variablar som saman med `varnamn` unikt identifiserer kvar måling.
(Det svarar altså til *primærnøklar* i databasesamanheng.)

Eit register har vanlegvis målingar av ulike datatypar,
for eksempel både tal (som ovanfor) og datoar eller logiske variablar
(`TRUE`/`FALSE`).
Men i dei fleste datasystem kan ein kolonne berre innehalda data av éin type.
Dette løyser me ved å innføra fleire verdikolonnar,
éin for kvar type variabel.
Me treng då òg ein kolonne `vartype` som seier kva type variabel
som kvar verdi gjeld.

I sjeldne tilfelle indeksvariablar ha same som verdivariablane.
Det prøver me å løysa ved å gje sistnemnde det uvanlege prefikset
*vld_* («validering»).
Dette er å rekna som eit reservert prefiks,
så ingen av indeksvariablane kan bruka det.

I det endelege formatet er det framleis slik at kvar rad
indentifiserer ei *måling* (med to verdiar, intern og ekstern):

```{r eksempel format, echo = FALSE}
d_format = tibble::tribble(
  ~pasid, ~dato_inn, ~vld_varnamn, ~vld_vartype, ~vld_verdi_intern_dato, ~vld_verdi_ekstern_dato, ~vld_verdi_intern_tal, ~vld_verdi_ekstern_tal,
  5, as.Date("2020-06-07"), "dato_ut", "dato", as.Date("2020-06-15"), as.Date("2020-06-15"), NA, NA,
  5, as.Date("2020-06-07"), "vekt", "tal", NA, NA, 78, 78,
  5, as.Date("2020-12-13"), "dato_ut", "dato", as.Date("2020-12-13"), as.Date("2020-12-14"), NA, NA,
  5, as.Date("2020-12-13"), "vekt", "tal", NA, NA, 50, 50,
  7, as.Date("2020-08-09"), "dato_ut", "dato", as.Date("2020-08-13"), as.Date("2020-08-13"), NA, NA,
  7, as.Date("2020-08-09"), "hogd", "tal", NA, NA, 196, 194
)
lag_kable(d_format)
```


## Bruk av valideringsdatasett

Når me har eit ferdig valideringsdatsett, er det svært lett å
rekna ut statistikk for det. Denne kan me så bruka i tabellar og
figurar i valideringsrapportar.


### Total korrektheit

Det lettaste er å rekna ut total korrektheit for registeret.
Då får me svar på sannsynet for at ein tilfeldig valt verdi
i registeret er ført korrekt:

Statistikken, inkludert konfidensintervalla, er naturlegvis
berre gyldig dersom radene i valideringsdatasettet er eit
*tilfeldig utval* av alle verdiane registrert i registeret,
altså viss alle målingar har like stort sannsyn for å vera
med i valideringsanalysen. Meir om tilfeldige utval i avsnitt xxx.


### Korrektheit per variabel

Nokre variablar er gjerne oftare registrerte korrekt enn andre.
Då kan me sjå på korrektheit per variabel:


Her er statistikken gyldig dersom det for kvar variabel er slik
at radene i valideringsdatasettet svarar til eit tilfeldig utval
av verdiane til tilhøyrande variabel i registeret. Men ein treng
ikkje ha like mange verdiar for kvar variabel, og ein kan for eksempel
validera fleire verdiar for viktige variablar enn for uviktige.
Men merk at då er ikkje lenger statistikken for total korrektheit
forventingsrett, og konfidensintervalla der kan ikkje brukast.
(Ev. flytta dette avsnittet seinare, og berre så vidt hinta om det her.)

Kan òg enkelt visa det som ein figur:

(Enkel figur utan mykje finpussing.)

Her kan (og bør) ein sjølvsagt finpussa figuren for å gjera
han meir brukarvennleg, men det er ikkje fokus for denne vignetten.


### Per månad, for å sjå utviklinga over tid

Når me driv forbetring for å auka korrektheita i eit register,
kan me sjå på korrektheit over tid:


### Per sjukehus

Viss nokre sjukehus er flinkare til å registrera korrekte data,
kan me finna ut av det:

Kan sjølvsagt kombinerast med andre gruppering,
som per variabel eller over tid.

For analyse for samanlikning av sjukehus, eller av enkeltsjukehus
over tid, tilrår me SPC-metodikk (som me ikkje skriv om her i vignetten).



## Generering av valideringsdatasett

Når ein har registerdata, er det med denne pakken veldig lett å
laga eit valideringsdatasett. Ein gjev inn eit datasett med indeksvariablar
og datavariablar, og ein vektor med namna på indeksvariablane til funksjonen 
`lag_valideringsdatasett()` og får ut eit valideringsdatasett.

### Eksempel på register

Me har eit enkelt register som registrerer vekt, høgd, om pasienten har opplevd
biverknad, og i så fall kva type biverknad. Nokre av variablane i registeret kan 
sjå slik ut:

```{r lageksempel, echo = FALSE}
d_reg = tibble::tribble(
  ~pasid, ~dato_inn, ~kjonn, ~sjukehus, ~dato_ut, ~vekt, ~hogd, ~biverk, ~biverk_hovud, ~biverk_mage, ~biverk_fot,
  5, as.Date("2020-06-07"), "M", "Bergen", as.Date("2020-06-15"), 78, 183, TRUE, FALSE, TRUE, TRUE,
  5, as.Date("2020-12-13"), "M", "Førde", as.Date("2020-12-13"), 50, 179, TRUE, FALSE, TRUE, TRUE,
  7, as.Date("2020-08-09"), "K", "Bergen", as.Date("2020-08-13"), 711, 196, TRUE, TRUE, TRUE, TRUE,
  13, as.Date("2021-01-05"), "M", "Førde", NA, NA, 163, FALSE, NA, NA, NA,
  14, as.Date("2021-01-05"), "M", "Førde", as.Date("2021-01-09"), 101, 182, TRUE, TRUE, FALSE, FALSE
)
lag_kable(d_reg)
```

I dette eksempelet er indeksvariablane `pasid` og `dato_inn`, medan `kjonn` og 
`sjukehus` er tilleggsvariablar som ein fjernar før bruk av 
`lag_valideringsdatasett()`. Dette gjer ein enkelt på følgjande måte: 
`select(d_reg, -kjonn, -sjukehus)`. Når det er gjort er ein klar
til å laga valideringsdatasettet.

### Komplett valideringsdatasett

Når ein køyrer `lag_valideringsdatasett()` får ein ut eit komplett 
valideringsdatasett, dersom ein ikkje har gjort ei filtrering av 
registerdatasettet på førehand. Eit komplett valideringsdatasett vil seie at 
alle variablar for alle pasientar/forløp er med. Talet på rader i 
valideringsdatasettet vert då lik talet på rader i det opphavlege datasettet 
gongar talet på datavariablar. For eksempelet over, med 5 rader og 7 
*datavariablar*, får ein eit valideringsdatasett med 35 rader. Her er dei 
fyrste 7 radene i dette valideringsdatasettet, som svarar til den fyrste rada 
i det opphavlege datasettet:

```{r eksempel valideringsdatasett, echo = FALSE}
indvars = c("pasid", "dato_inn")
vartypar = c("dato", "tal", "tal", "logisk", "logisk", "logisk", "logisk")
d_vld = d_reg %>%
  select(-kjonn, -sjukehus) %>%
  lag_valideringsdatasett(indvars, vartypar)
d_vld %>%
  head(7) %>%
  lag_kable()
```

Det er likevel ofte at ein ikkje ynskjer eit komplett valideringsdatasett, 
med alle variablar for alle pasientar/forløp. Kanskje ein ynskjer å avgrensa
til eit visst antal rader, berre nokre visse sjukehus eller liknande. Under
er eksempel på fleire scenario og korleis ein kan gå fram skildra.


### Korleis lagra til SPSS-format?

Nokre få linjer kode for å få éi fil per sjukehus.


### Utval av variablar

Dersom ein berre skal sjå på eit utval av variablane, kan ein gjera dette ved
å fjerna variablane som ikkje skal vera med, før ein kallar 
`lag_valideringsdatasett()`. Dette kan ein gjera på same måte som ein fjernar 
tilleggsvariablar:

```
select(d_reg, -dato_ut)
```

Eventuelt kan ein gjera det motsett, og velja dei variablane som *skal* vera 
med, dersom det er enklare. Då må ein hugsa på å også ta med indeksvariablane:

```
select(d_reg, pasid, dato_inn, vekt, hogd)
```

#### Bruk av logikk til å fjerna unødvendige rader

Det finst eksempel på at visse variablar berre gjev meining å sjekka dersom 
ein annan variabel har ein viss verdi. Det kan til dømes vera at ein har 
variabelen gravid, som berre gjev meining å sjekka dersom kjønn er kvinne. 
Slike rader kan ein fjerna frå valideringsdatasettet på denne måten:

```
d_vld_med_metadata %>% # her har me kopla på metadata for å få kolonnen kjonn
  filter(!(kjonn="mann" && varnamn == "gravid"))
```

Eit anna eksempel kan vera variablar som 1-års-vekt, som ikkje skal sjekkast 
for pasientar som vart operert for mindre enn 1 år sidan:

```
d_vld %>%
  filter(!(varnamn == "vekt_1aar" && op_dato > Sys.Date()-365))
```

### Utval av visse variabelverdiar

Ein kan avgrense uttrekket til visse verdiar for éin eller fleire variablar,
til dømes dersom ein berre skal kontrollera data på eitt eller fleire 
særskilde sjukehus. Dette kan gjerast ved å bruka filtrera på ynskja verdiar
før ein kallar `lag_valideringsdatasett()`:

```
filter(d_reg, sjukehus == "Bergen")
```

### Ymse typar tilfeldige utval

statistisk kommentar? eller berre la det stå i førre kapittel?

20 % av forløpa per variabel

Stadig meir vanskelege/avanserte eksempel

joining med andre datasett

stikkord:

- tilfeldig rekkjefølgje (*alle* rader)
- sample_n()
- sample_frac()
- per variabel?
- per pasient?
- sjå kommentarar lenger ned i vignetten for ulike eksempel (lag éi overskrift per eksempel)

#### Tilfeldig utval av n rader

For å trekkja ut n tilfeldige rader køyrer ein følgjande kode med
valideringsdatasettet `d_vld`:

`sample_n(d_vld, n)`

#### Tilfeldig utval av andel av rader

For å trekkja ut x andel tilfeldige rader køyrer ein følgjande kode med
valideringsdatasettet`d_vld`:

`sample_frac(d_vld, x)`

#### Komplett valideringsdatasett i tilfeldig rekkjefølgje

Det kan vera ynskjeleg å bruka eit komplett valideringsdatasett i 
korrektheitsstudien, slik at ein jobbar seg gjennom så mykje ein klarar på 
ei gitt tid, men då i tilfeldig rekkjefølgje, slik at ein får eit tilfeldig 
utval. For å få til dette køyrer ein følgjande kode med valideringsdatasettet 
`d_vld`:

`sample_frac(d_vld)`

#### Komplett valideringsdatasett med pasientar i tilfeldig rekkjefølgje

Dersom det er lite føremålstenleg å ha rader for same pasient på ulike stadar
i valideringsdatasettet kan ein trekkja alle pasientane i tilfeldig rekkjefølgje
og så ta med alle variablane for kvar pasient etter kvarandre. Dette kan gjerast 
ved å køyra følgjande kode med valideringsdatasettet `d_vld`:

```
rekkjefolgje = sample(unique(d_vld$pasid))
arrange(d_vld, match(pasid, rekkjefolgje), dato_inn)
```

#### Tilfeldig utval av n forløp eller pasientar

For å trekkja ut n tilfeldige forløp køyrer ein følgjande kode med registerdata
`d_reg` og valideringsdatasettet`d_vld`:

```
uttrekk_forlop = select(d_reg, pasid, dato_inn) %>% # pasid og dato_inn er indeksvariablane 
                                                    # bruk berre pasid dersom det skal veljast ut 
                                                    # pasientar og ikkje forløp
    sample_n(n)

semi_join(d_vld, uttrekk_forlop)
```

#### Tilfeldig utval av k variablar, og så tilfeldig utval av m forløp per variabel

```
uttrekk_variablar = sample(unique(d_vld$vld_varnamn), k)
d_uttrekk = d_vld[c(),]
for(variabel in uttrekk_variablar){
  d_variabel = filter(d_vld, vld_varnamn == variabel)
  uttrekk_forlop = select(d_variabel, pasid, dato_inn) %>%
    sample_n(m)
  uttrekk_variabel = semi_join(d_variabel, uttrekk_forlop)
  d_uttrekk = add_row(d_uttrekk, uttrekk_variabel)
}
d_uttrekk
```

#### Prioritering av visse variabelverdiar

I nokre tilfelle ynskjer ein å prioritera pasientar/forløp med visse 
variabelverdiar, som til dømes ein viss diagnose. I eksempelregisteret vårt
kan det tenkjast at ein vil prioritera pasientar med verdien `TRUE` på 
`biverk_hovud`. Dersom dette registeret hadde hatt fleire forløp registrert, 
kan ein sjå føre seg at ein til dømes ville trekkja ut 80 tilfeldige forløp
med verdien `TRUE` på `biverk_hovud`, og 20 % blant resten. Dette kan gjerast 
fylgjande måte:

```
d1 = filter(d_vld, biverk_hovud == TRUE)
d2 = setdiff(d_vld, d1)
d1_uttrekk = sample_n(d1, size = 80)
d2_uttrekk = sample_frac(d2, size = .2)
bind_rows(d1_uttrekk, d2_uttrekk)
```

#### Samanhengande variablar

Visse variablar kan vera samanhengande ved at dei liknar eller er avhengig av 
kvarandre, som til dømes biverknadvariablane i eksempelregisteret vårt. Det 
kan vera føremålstenleg å inkludera alle slike samanhengande variablar for 
kvart forløp det éin eller fleire av dei er trekt ut:

```
d_vld_biverk = d_vld %>%
  filter(vld_varnamn %in% c("biverk", "biverk_hovud", "biverk_mage", "biverk_fot")) %>% 
  distinct(pasid, dato_inn)

d_vld_komplett_biverk = d_vld_komplett %>% 
  filter(vld_varnamn %in% c("biverk", "biverk_hovud", "biverk_mage", "biverk_fot")) %>% 
  inner_join(d_vld_biverk)
  
full_join(d_vld, d_vld_komplett_biverk)
```

### Fornuftig rekkjefølgje

Etter at ein har gjort eit tilfeldig utval kan det vera føremålstenleg å ha 
radene i ei fornuftig rekkjefølgje. 

#### Sorter rader etter forløp

```
arrange(d_uttrekk, pasid, dato_inn)
```

#### Sorter rader etter variablar

```
var_rekkjefolgje = c("hogd", "vekt", "dato_ut")
arrange(d_uttrekk, match(vld_varnamn, var_rekkjefolgje))
```

#### Sorter rader etter forløp og variablar

```
arrange(d_uttrekk, pasid, dato_inn, match(vld_varnamn, var_rekkjefolgje))
```

### Ekstra kolonnar med informasjon

Det kan vera nyttig å leggja til ekstra kolonnar i valideringsdatasettet, til 
dømes metadata som fødselsdato, alder og kjønn som kan gjera det enklare å
finna pasienten i pasientjournalen. Dette kan gjerast ved å kopla på igjen 
kolonnar frå registerdatasettet på valideringsdatasettet:

```
left_join(d_vld, select(d_reg, pasid, dato_inn, kjonn, sjukehus), by = c("pasid", "dato_inn"))
```

<!-- Behovskartlegging

*I funksjonen bør det legges til mulighet for å hente ut et visst antall pasienter i utvalget (nå tas uansett alle sammen med per SPSS-fil, som er uoverkommelig for mange registre).
-> sample_frac() elns.

Vi trenger altså en fil for hvert av de 6 angitte sykehusene, med f.eks. 100 pasienter med de 4 diagnosegruppene.
-> funksjon for lagring()???

*Viktig at RA-pasienter med diagnose 2014 eller seinere prioriteres (minst 50 pasienter der det finnes).
-> potensielt statistisk problematisk? viss sannsynet for å trekkast ut er avhengig av nokre variabelverdiar, for eksempel diagnose. uproblematisk ved *stratifisert* analyse eller ved rett justering.
-> d1 = filter(diag == "ra")
    d2 = filter(diag != "ra") ## antar ingen NA-ar
    d1_utval = sample_n(d1, n = 50)
    d2_utval = sample_frac(d2, frac = .2)
    d_utval = bind_rows(d1_utval, d2_utval)
    ## (i staden for d_utval = sample_frac(d, frac = .2)

*Når det gjelder diagnose og diagnosedato skal vi ikke undersøke om disse er korrekt registrert, for her er det mye skjønn og det er OK. Vi trenger dette til å se på en del av de senere punktene. Derfor ønsker vi at diagnose og diagnosedato som er registrert i NorArtritt skal ligge i filen som vi skal fylle inn slik at vi kan sammenholde.
For de andre variablene trenger vi ikke å ha NorArtritt dataene i filen."
-> left_join(d_utval, select(d_regdata, utvalde_kolonnar, ...))

*1) Hvis de henter tilfeldige variabler per pasient, ala SOReg-løsningen, kunne det vært slik at hvis en variabel som ble plukket ut var fra et sett med lignende variabler, så ble alle variablene i settet hentet for pasienten (eksemepelet var en rekke avkrysningsbokser for symptomer - hvis en variabel for et symptom, la oss si hodepine, blir trukket ut av variabel-rouletten, så ville de at variabelen for kvalme, kløe og fotsopp også ble med på den pasienten)
-> d_utval %>%
  left_join(d_regdata) %>%
  group_by(pasid) %>%
  filter(!(variabel1 != x, varnamn %in% c(variabel2, variabel3 osv.))) ## noko sånt ... :9

*2) At man hadde logikker med, at hvis pasienten har verdien er mann = ja så får ikke denne pasienten variabelen for graviditet med i sitt variabelsett. SOReg ville ha noe lignende - at man ikke fikk variabelen for 6 vekers vekt når pasienten fikk operasjonen sin i går.
-> d_vld_med_md %>%
  filter(!(kjonn="mann" && varnamn == "gravid))

*Tilfeldig utval av n pasientar.
-> 
  akt_pasientar = select(d_regdata, pasid, dato_inn) %>%
    ## ev. distinct() %>% ## viss det er pasientar og ikkje forløp me vil ha
    sample_n(n) %>%
  semi_join(d_utval, akt_pasientar)

*Tilfeldig utval av k variablar, og så tilfeldig utval av m pasientar per variabel.
->
  akt_variablar = sample(d_utval$varnamn, k)
  filter(d_utval, varnamn %in% akt_variablar)

*Variablane skal visast i ei fornuftig rekkjefølgje (sortert etter pasient,
eller etter ei spesiell variabelrekkjefølgje)
->
  ## Pasientar
  arrange(d_utval, pasid, dato_inn)

  ## Variabel
  var_rekkjefolgje = c("hogd", "vekt", "dato_ut")
  arrange(d_utval, !!match(varnamn, var_rekkjefolgje)) ## ??? Noko sånt, jaffal
  ## Men det lettaste er å ha variablane i god rekkjefolgje i utgangspunktet

Ev. annan funksjonalitet i opphavleg funksjon?
->
  ?
  
  Frå https://www.kvalitetsregistre.no/sites/default/files/2021-02/Erfaringer%20med%20valideringsstudie%20for%20SOReg-N.pdf finn me følgjande eksempel:
  
*«Registeret ble enige med
statistikerne om å trekke et overkommelig antall, tilfeldige variabler
per operasjon (operasjon = omtrent det samme som pasient, men
noen få pasienter hadde hatt reoperasjoner). Planen var i
utgangspunktet 7 tilfeldige variabler per operasjon.
[...] En erfaring var at å finne mange variabler for en pasient var lettere
enn å åpne ny journal for å finne verdiene til en ny pasient. På bakgrunn av
dette økte en antall tilfeldige valgte variabler til 10 variabler per pasient.»
Bør ha eksempel på korleis ein gjer dette.

*Eksempel på at ein legg til ekstra metadata (eks. fødselsdato, alder og kjønn)
for å lettare finna pasienten i pasientjournalen.

*Eksempel på variabelrekkjefølgje:

*«Rekkefølgene på radene var basert på en «naturlig» rekkefølge (for
eksempel kom baseline-variabler før oppfølgingsvariabler), slik at det
skulle være enklere og raskere å finne frem til informasjonen i
pasientjournalen.»

Eksempel på:

«Videre viste det seg at mange av variablene var uaktuelle for enkelte pasienter.
Det var ikke aktuelt å se på 1-års-vekt til pasienter som nylig hadde hatt sin
operasjon og 1-års-oppfølging ikke var aktuelt enda. På bakgrunn av dette
kunne statistikere legge til i datasettet at variabler som gjaldt målinger på 6-
ukers og 1-års oppfølging bare dukket opp for pasienter som var aktuelle for
disse oppfølgingene.»

Eige kapittel om statistikk, med råd om å bruka survey-pakken
og lesa ei survey-boka. Og SSBs notat som ulike samplingsmåtar?

  
  Laging av eigne samanlikningfunksjonar (eiga avansert-kapittel).
  Og så må det stå om korleis standard samanlikningsfunksjon fungerer
  (spesielt om korleis handterer NA-verdiar).
  
Frå NORIC og AblaNor:
Me ønsker 
*-	at det skal vera mogleg å bestemma kva variabler som skal kontrollerast (til dømes dersom me veit at det er mykje feil i nokre felt vil me heller kontrollera dei felta enn tilfeldig utvalde variablar)
*-	å kunne avgrensa kor mange variabler som skal trekkjast ut + antal pasientar (Dersom prosjektet vert for stort er det vanskelig å finna ressursane til å gjennomføra det)
*-	at det er mogleg å avgrensa til utvalde sjukehus. (Til dømes dersom me veit at det er mykje feil i Stavanger kan me ha mål om å forbetra kvaliteten på innregistreringa der)
-	ein mal på korleis ein skal registrera samanlikningane ein gjer (Excel ark ein kan fylla inn i? Eller anna løysing? )
-	ein mal/døme på ferdig rapport. Til dømes flytskjema, oppteljingar per pasient/variabel med andel like/ulike registreringar, figurar 
-	gjerne ein halvautomatisert rapport. Me bruker rmd-format og tykkjer det fungerer fint. Kanskje ei rmd-fil me kan fylla parametre inn i kunne vore ein ide? Til dømes at me får første og siste registrering, dato for rapport, figurar, tabellar, overskrifter osv., så fyller me sjølve inn tekst og kompletterer ved behov. 

Sjå tekst og lenkjer på https://www.kvalitetsregistre.no/korrekthet
Verdt å merka seg:
«For kontinuerlige variabler (eksempelvis høyde eller vekt) bør man også
analysere hvor stort avviket er fra den sanne verdien. En variabel hvor
avviket fra gullstandarden er stort er mer problematisk enn hvor
avviket er lite.»
Funksjon for å laga KI-variabel for kontinuerlege variablar?
Absoluttavvik (standard) eller avvik med forteikn?
  
-->
